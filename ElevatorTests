"""
Comprehensive Test Suite for Elevator System
Tests for 3 elevators, 18 floors based on PRD
"""

import unittest
import time
import threading
from datetime import datetime
from unittest.mock import Mock, patch
import sys

# Import the elevator system classes
# Note: These would be your actual class imports
# For this test, I'll create mock versions of the key classes

# ========== MOCK SETUP FOR TESTING ==========
# In reality, you'd import your actual classes
class Direction:
    UP = "UP"
    DOWN = "DOWN"
    IDLE = "IDLE"

class MockElevator:
    def __init__(self, elevator_id, start_floor=1):
        self.id = elevator_id
        self.current_floor = start_floor
        self.direction = Direction.IDLE
        self.target_floors = set()
        self.door_open = False
        self.is_moving = False
        self.emergency_active = False
        self.overloaded = False
        self.trip_count = 0
        
    def move_to_floor(self, floor):
        self.target_floors.add(floor)
        self.is_moving = True
        floors_to_move = abs(self.current_floor - floor)
        self.current_floor = floor
        self.trip_count += 1
        return floors_to_move
        
    def open_doors(self):
        if not self.is_moving:
            self.door_open = True
            return True
        return False
        
    def close_doors(self):
        self.door_open = False
        return True
        
    def emergency_stop(self):
        self.emergency_active = True
        self.is_moving = False
        self.door_open = True
        return True

class MockElevatorSystem:
    def __init__(self):
        self.elevators = {
            1: MockElevator(1, 1),
            2: MockElevator(2, 9),
            3: MockElevator(3, 18)
        }
        self.hall_calls = []
        
    def call_elevator(self, floor, direction):
        self.hall_calls.append((floor, direction))
        # Simple dispatch: find nearest idle elevator
        best_elevator = None
        min_distance = float('inf')
        
        for elevator in self.elevators.values():
            if not elevator.is_moving and not elevator.emergency_active:
                distance = abs(elevator.current_floor - floor)
                if distance < min_distance:
                    min_distance = distance
                    best_elevator = elevator
                    
        if best_elevator:
            best_elevator.move_to_floor(floor)
            return best_elevator.id
        return None

# ========== UNIT TESTS ==========
class TestElevatorUnit(unittest.TestCase):
    """Unit tests for individual elevator components"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.elevator = MockElevator(1, start_floor=5)
    
    def test_elevator_initialization(self):
        """Test elevator initializes with correct values"""
        self.assertEqual(self.elevator.id, 1)
        self.assertEqual(self.elevator.current_floor, 5)
        self.assertEqual(self.elevator.direction, Direction.IDLE)
        self.assertEqual(self.elevator.trip_count, 0)
        self.assertFalse(self.elevator.door_open)
        self.assertFalse(self.elevator.is_moving)
    
    def test_move_to_higher_floor(self):
        """Test moving elevator to a higher floor"""
        floors_moved = self.elevator.move_to_floor(10)
        self.assertEqual(self.elevator.current_floor, 10)
        self.assertEqual(floors_moved, 5)
        self.assertIn(10, self.elevator.target_floors)
        self.assertEqual(self.elevator.trip_count, 1)
    
    def test_move_to_lower_floor(self):
        """Test moving elevator to a lower floor"""
        self.elevator.current_floor = 15
        floors_moved = self.elevator.move_to_floor(3)
        self.assertEqual(self.elevator.current_floor, 3)
        self.assertEqual(floors_moved, 12)
    
    def test_door_operations(self):
        """Test door open/close operations"""
        # Can open doors when not moving
        result = self.elevator.open_doors()
        self.assertTrue(result)
        self.assertTrue(self.elevator.door_open)
        
        # Can close doors
        result = self.elevator.close_doors()
        self.assertTrue(result)
        self.assertFalse(self.elevator.door_open)
    
    def test_emergency_stop(self):
        """Test emergency stop functionality"""
        self.elevator.is_moving = True
        self.elevator.door_open = False
        
        result = self.elevator.emergency_stop()
        
        self.assertTrue(result)
        self.assertTrue(self.elevator.emergency_active)
        self.assertFalse(self.elevator.is_moving)
        self.assertTrue(self.elevator.door_open)  # Doors should open in emergency
    
    def test_cannot_open_doors_while_moving(self):
        """Test safety: cannot open doors while elevator is moving"""
        self.elevator.is_moving = True
        result = self.elevator.open_doors()
        self.assertFalse(result)
        self.assertFalse(self.elevator.door_open)
    
    def test_multiple_floor_requests(self):
        """Test handling multiple floor requests"""
        self.elevator.move_to_floor(8)
        self.elevator.move_to_floor(12)
        self.elevator.move_to_floor(3)
        
        self.assertIn(8, self.elevator.target_floors)
        self.assertIn(12, self.elevator.target_floors)
        self.assertIn(3, self.elevator.target_floors)
        self.assertEqual(len(self.elevator.target_floors), 3)

# ========== INTEGRATION TESTS ==========
class TestElevatorSystemIntegration(unittest.TestCase):
    """Integration tests for the complete elevator system"""
    
    def setUp(self):
        """Set up system for integration tests"""
        self.system = MockElevatorSystem()
    
    def test_system_initialization(self):
        """Test system initializes with 3 elevators at correct floors"""
        self.assertEqual(len(self.system.elevators), 3)
        self.assertEqual(self.system.elevators[1].current_floor, 1)   # Ground floor
        self.assertEqual(self.system.elevators[2].current_floor, 9)   # Mid floor
        self.assertEqual(self.system.elevators[3].current_floor, 18)  # Top floor
    
    def test_hall_call_dispatch(self):
        """Test hall call gets dispatched to nearest idle elevator"""
        # Call from floor 3 going UP
        elevator_id = self.system.call_elevator(3, Direction.UP)
        
        # Should dispatch elevator 1 (at floor 1, distance 2)
        self.assertEqual(elevator_id, 1)
        self.assertEqual(self.system.elevators[1].current_floor, 3)
        self.assertEqual(self.system.hall_calls, [(3, Direction.UP)])
    
    def test_concurrent_hall_calls(self):
        """Test multiple simultaneous hall calls"""
        # Simulate rush hour: multiple calls at once
        results = []
        calls = [
            (1, Direction.UP),   # Person at ground floor
            (5, Direction.UP),   # Person at floor 5
            (10, Direction.DOWN) # Person at floor 10
        ]
        
        for floor, direction in calls:
            elevator_id = self.system.call_elevator(floor, direction)
            results.append(elevator_id)
        
        # All calls should be assigned
        self.assertEqual(len(results), 3)
        self.assertIsNotNone(results[0])
        self.assertIsNotNone(results[1])
        self.assertIsNotNone(results[2])
        
        # Verify elevators moved
        self.assertTrue(self.system.elevators[1].is_moving)
        self.assertTrue(self.system.elevators[2].is_moving)
    
    def test_elevator_busy_fallback(self):
        """Test dispatch when some elevators are busy"""
        # Make elevator 1 busy
        self.system.elevators[1].is_moving = True
        self.system.elevators[1].current_floor = 15
        
        # Make elevator 3 in emergency
        self.system.elevators[3].emergency_active = True
        
        # Call from floor 8
        elevator_id = self.system.call_elevator(8, Direction.UP)
        
        # Should dispatch elevator 2 (only available)
        self.assertEqual(elevator_id, 2)
        self.assertEqual(self.system.elevators[2].current_floor, 8)
    
    def test_floor_boundaries(self):
        """Test calls at boundary floors"""
        # Floor 1 should not have DOWN call
        # Floor 18 should not have UP call
        # These should be handled in the actual implementation
        pass
    
    def test_trip_counting(self):
        """Test that trips are counted correctly"""
        initial_trip_counts = {
            1: self.system.elevators[1].trip_count,
            2: self.system.elevators[2].trip_count,
            3: self.system.elevators[3].trip_count
        }
        
        # Make several trips
        self.system.call_elevator(5, Direction.UP)
        self.system.call_elevator(10, Direction.UP)
        self.system.call_elevator(15, Direction.DOWN)
        
        # Verify trip counts increased
        self.assertGreater(self.system.elevators[1].trip_count, initial_trip_counts[1])
        self.assertGreater(self.system.elevators[2].trip_count, initial_trip_counts[2])

# ========== ALGORITHM TESTS ==========
class TestDispatchingAlgorithms(unittest.TestCase):
    """Tests for dispatching algorithm logic"""
    
    def setUp(self):
        self.system = MockElevatorSystem()
    
    def test_nearest_idle_elevator(self):
        """Test PRD algorithm: nearest idle elevator gets call"""
        # Reset all to idle
        for e in self.system.elevators.values():
            e.is_moving = False
        
        # Elevator positions: 1@1, 2@9, 3@18
        # Call from floor 6 should go to elevator 2 (distance 3)
        elevator_id = self.system.call_elevator(6, Direction.UP)
        self.assertEqual(elevator_id, 2)
    
    def test_moving_toward_request(self):
        """Test elevator moving toward request gets priority"""
        # Set elevator 1 moving UP from floor 3 to 10
        self.system.elevators[1].current_floor = 3
        self.system.elevators[1].is_moving = True
        
        # Set elevator 2 idle at floor 9
        self.system.elevators[2].is_moving = False
        
        # Call from floor 5 going UP
        # Elevator 1 (moving toward floor 5) should get it
        # This tests the "moving toward request" logic
        pass
    
    def test_direction_priority(self):
        """Test that direction is considered in dispatch"""
        # Elevator 1 at floor 4 moving UP
        # Elevator 2 at floor 6 moving DOWN
        # Call from floor 5 going UP should prefer elevator 1
        pass
    
    def test_scenario_based_dispatch(self):
        """Test complex dispatch scenario"""
        # Scenario: Morning rush - many UP calls from lower floors
        calls = [
            (1, Direction.UP), (2, Direction.UP), (3, Direction.UP),
            (4, Direction.UP), (5, Direction.UP)
        ]
        
        for floor, direction in calls:
            self.system.call_elevator(floor, direction)
        
        # Verify distribution of calls
        # Should use all elevators efficiently
        pass

# ========== SCENARIO TESTS ==========
class TestRealWorldScenarios(unittest.TestCase):
    """Real-world scenario tests based on PRD"""
    
    def test_morning_rush_hour(self):
        """Test PRD Scenario: Morning upward traffic"""
        system = MockElevatorSystem()
        
        # Simulate 8:00 AM rush
        # Multiple people entering from ground floor going up
        results = []
        destinations = [8, 12, 15, 10, 18]  # Various office floors
        
        for dest in destinations:
            # Person calls elevator
            elevator_id = system.call_elevator(1, Direction.UP)
            if elevator_id:
                # Person selects destination
                system.elevators[elevator_id].move_to_floor(dest)
                results.append((elevator_id, dest))
        
        # Should have handled all requests
        self.assertEqual(len(results), 5)
        
        # Check trip distribution
        elevator_trips = {1: 0, 2: 0, 3: 0}
        for elevator_id, _ in results:
            elevator_trips[elevator_id] += 1
        
        # All elevators should be used
        self.assertTrue(all(count > 0 for count in elevator_trips.values()))
    
    def test_lunch_hour_bidirectional(self):
        """Test PRD Scenario: Lunchtime bidirectional traffic"""
        system = MockElevatorSystem()
        
        # Lunch hour: people going both directions
        # Some going down to cafeteria (floor 2)
        # Some going up back to offices
        
        down_calls = [(10, Direction.DOWN), (15, Direction.DOWN), (8, Direction.DOWN)]
        up_calls = [(2, Direction.UP), (2, Direction.UP), (2, Direction.UP)]
        
        all_results = []
        
        for floor, direction in down_calls + up_calls:
            elevator_id = system.call_elevator(floor, direction)
            if elevator_id:
                if direction == Direction.DOWN:
                    system.elevators[elevator_id].move_to_floor(2)  # To cafeteria
                else:
                    system.elevators[elevator_id].move_to_floor(random.choice([10, 12, 15]))  # Back to office
                all_results.append(elevator_id)
        
        # Should handle mixed traffic
        self.assertEqual(len(all_results), 6)
    
    def test_emergency_scenario(self):
        """Test emergency situation handling"""
        system = MockElevatorSystem()
        
        # Normal operation
        system.call_elevator(5, Direction.UP)
        
        # Emergency activated in elevator 2
        system.elevators[2].emergency_stop()
        
        # Verify emergency state
        self.assertTrue(system.elevators[2].emergency_active)
        self.assertTrue(system.elevators[2].door_open)
        self.assertFalse(system.elevators[2].is_moving)
        
        # System should still operate with other elevators
        elevator_id = system.call_elevator(10, Direction.DOWN)
        self.assertIsNotNone(elevator_id)
        self.assertNotEqual(elevator_id, 2)  # Should not use emergency elevator
    
    def test_overload_prevention(self):
        """Test overload detection and prevention"""
        elevator = MockElevator(1)
        
        # Simulate overload condition
        elevator.overloaded = True
        
        # Should not move when overloaded
        self.elevator.overloaded = True
        result = self.elevator.move_to_floor(10)
        # In actual implementation, move_to_floor should check overload
        
        # Doors should not close when overloaded
        elevator.door_open = True
        result = elevator.close_doors()
        # In actual implementation, should prevent closing when overloaded
    
    def test_door_safety_features(self):
        """Test door safety mechanisms"""
        elevator = MockElevator(1)
        
        # Test door obstruction simulation
        # In actual implementation, doors should reopen if obstruction detected
        pass
    
    def test_power_outage_recovery(self):
        """Test system behavior during power outage"""
        system = MockElevatorSystem()
        
        # Simulate power outage
        # Elevators should stop at nearest floor
        # Emergency lighting should activate
        # Backup power should allow door opening
        pass

# ========== PERFORMANCE TESTS ==========
class TestPerformanceMetrics(unittest.TestCase):
    """Performance and metric tests based on PRD KPIs"""
    
    def test_average_wait_time(self):
        """Test PRD KPI: Average wait time < 30 seconds"""
        system = MockElevatorSystem()
        
        # Simulate 100 calls and measure response time
        response_times = []
        
        for i in range(1, 11):  # 10 test calls
            start_time = time.time()
            system.call_elevator(i, Direction.UP)
            response_time = time.time() - start_time
            
            # In real system, response_time would be actual dispatch time
            # For mock, we'll use simulated values
            simulated_response = 0.1 * i  # Varies by floor
            response_times.append(simulated_response)
        
        average_wait = sum(response_times) / len(response_times)
        
        # Should meet PRD requirement
        self.assertLess(average_wait, 30.0, 
                       f"Average wait time {average_wait:.2f}s exceeds 30s limit")
    
    def test_elevator_availability(self):
        """Test PRD KPI: 99.5% uptime"""
        # Simulate 1000 hours of operation
        total_hours = 1000
        maintenance_hours = 2  # 2 hours of maintenance
        emergency_hours = 3    # 3 hours of emergency downtime
        
        uptime_hours = total_hours - maintenance_hours - emergency_hours
        availability = (uptime_hours / total_hours) * 100
        
        self.assertGreaterEqual(availability, 99.5,
                               f"Availability {availability:.1f}% below 99.5% target")
    
    def test_energy_efficiency(self):
        """Test PRD KPI: Energy consumption tracking"""
        # Track elevator movements
        elevator = MockElevator(1)
        
        # Simulate day's trips
        trips = [(1, 10), (10, 5), (5, 18), (18, 1)]
        total_floors = 0
        
        for start, end in trips:
            floors_moved = abs(start - end)
            total_floors += floors_moved
            elevator.move_to_floor(end)
        
        # Calculate energy (simplified: 1 unit per floor)
        energy_used = total_floors
        
        # Should be efficient (no unnecessary movements)
        self.assertLess(energy_used, 50,  # Arbitrary threshold
                       f"Energy usage {energy_used} seems excessive")
    
    def test_concurrent_request_handling(self):
        """Test system performance under concurrent load"""
        system = MockElevatorSystem()
        
        # Simulate 20 concurrent requests (stress test)
        import concurrent.futures
        
        def make_request(floor):
            return system.call_elevator(floor, Direction.UP)
        
        floors = list(range(1, 21))  # 20 concurrent calls
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            results = list(executor.map(make_request, floors))
        
        # Should handle all concurrent requests
        successful_calls = [r for r in results if r is not None]
        self.assertEqual(len(successful_calls), 3)  # All 3 elevators should be used

# ========== BOUNDARY TESTS ==========
class TestBoundaryConditions(unittest.TestCase):
    """Tests for edge cases and boundary conditions"""
    
    def test_floor_limits(self):
        """Test calls at minimum and maximum floors"""
        system = MockElevatorSystem()
        
        # Test valid floor 1
        result = system.call_elevator(1, Direction.UP)
        self.assertIsNotNone(result)
        
        # Test valid floor 18
        result = system.call_elevator(18, Direction.DOWN)
        self.assertIsNotNone(result)
        
        # Test invalid floors (should be handled gracefully)
        # These would raise exceptions in actual implementation
        pass
    
    def test_elevator_capacity(self):
        """Test at capacity limits"""
        elevator = MockElevator(1)
        
        # Simulate approaching capacity
        # Add many floor requests
        for floor in range(1, 19, 2):  # Odd floors
            elevator.move_to_floor(floor)
        
        # Should handle all requests
        self.assertEqual(len(elevator.target_floors), 9)
    
    def test_system_startup_shutdown(self):
        """Test system initialization and shutdown sequences"""
        system = MockElevatorSystem()
        
        # Verify proper startup
        self.assertEqual(len(system.elevators), 3)
        
        # Simulate shutdown
        # In real system, would park elevators, close doors, etc.
        pass
    
    def test_continuous_operation(self):
        """Test system stability during continuous operation"""
        system = MockElevatorSystem()
        
        # Simulate 24 hours of operation
        operations_count = 0
        
        for hour in range(24):
            # Varying load based on time of day
            if 7 <= hour <= 9:  # Morning rush
                calls_per_hour = 100
            elif 12 <= hour <= 14:  # Lunch rush
                calls_per_hour = 80
            elif 16 <= hour <= 18:  # Evening rush
                calls_per_hour = 120
            else:  # Off-peak
                calls_per_hour = 20
            
            for _ in range(calls_per_hour):
                floor = random.randint(1, 18)
                direction = random.choice([Direction.UP, Direction.DOWN])
                system.call_elevator(floor, direction)
                operations_count += 1
        
        # System should handle all operations
        self.assertGreater(operations_count, 1000)

# ========== TEST RUNNER ==========
def run_all_tests():
    """Run all test suites and generate report"""
    # Create test suite
    loader = unittest.TestLoader()
    
    # Add all test classes
    test_classes = [
        TestElevatorUnit,
        TestElevatorSystemIntegration,
        TestDispatchingAlgorithms,
        TestRealWorldScenarios,
        TestPerformanceMetrics,
        TestBoundaryConditions
    ]
    
    suites = []
    for test_class in test_classes:
        suite = loader.loadTestsFromTestCase(test_class)
        suites.append(suite)
    
    # Combine all suites
    all_tests = unittest.TestSuite(suites)
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(all_tests)
    
    # Generate summary
    print("\n" + "="*60)
    print("TEST SUMMARY")
    print("="*60)
    print(f"Total Tests Run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    
    if result.failures:
        print("\nFAILURES:")
        for test, traceback in result.failures:
            print(f"  {test}:")
            print(f"    {traceback.splitlines()[-1]}")
    
    if result.errors:
        print("\nERRORS:")
        for test, traceback in result.errors:
            print(f"  {test}:")
            print(f"    {traceback.splitlines()[-1]}")
    
    return result.wasSuccessful()

# ========== INDIVIDUAL TEST FUNCTIONS ==========
def test_specific_scenario(scenario_name):
    """Run a specific scenario test"""
    scenarios = {
        "morning_rush": test_morning_rush_scenario,
        "emergency": test_emergency_scenario,
        "overload": test_overload_scenario,
        "performance": test_performance_scenario
    }
    
    if scenario_name in scenarios:
        return scenarios[scenario_name]()
    else:
        print(f"Unknown scenario: {scenario_name}")
        return False

def test_morning_rush_scenario():
    """Detailed morning rush scenario test"""
    print("\n" + "="*60)
    print("RUNNING MORNING RUSH SCENARIO TEST")
    print("="*60)
    
    system = MockElevatorSystem()
    
    # Record elevator starting positions
    starting_positions = {
        1: system.elevators[1].current_floor,
        2: system.elevators[2].current_floor,
        3: system.elevators[3].current_floor
    }
    
    # Simulate 8:00-9:00 AM traffic
    calls = []
    
    # People arriving at building (mostly ground floor calls)
    for i in range(10):
        calls.append((1, Direction.UP, random.randint(5, 18)))
    
    # Some people already in building
    for i in range(5):
        start_floor = random.randint(2, 10)
        calls.append((start_floor, Direction.UP, random.randint(10, 18)))
    
    results = []
    for start_floor, direction, destination in calls:
        elevator_id = system.call_elevator(start_floor, direction)
        if elevator_id:
            system.elevators[elevator_id].move_to_floor(destination)
            results.append({
                'elevator': elevator_id,
                'from': start_floor,
                'to': destination
            })
    
    # Analyze results
    print(f"Total requests: {len(calls)}")
    print(f"Handled requests: {len(results)}")
    
    elevator_stats = {1: 0, 2: 0, 3: 0}
    for result in results:
        elevator_stats[result['elevator']] += 1
    
    print("\nElevator utilization:")
    for elevator_id, count in elevator_stats.items():
        print(f"  Elevator {elevator_id}: {count} trips")
    
    # Verify all elevators were used
    assert all(count > 0 for count in elevator_stats.values()), \
        "Not all elevators were utilized during rush hour"
    
    print("\n✓ Morning rush scenario test PASSED")
    return True

def test_emergency_scenario():
    """Detailed emergency scenario test"""
    print("\n" + "="*60)
    print("RUNNING EMERGENCY SCENARIO TEST")
    print("="*60)
    
    system = MockElevatorSystem()
    
    # Normal operation first
    print("1. Normal operation...")
    system.call_elevator(5, Direction.UP)
    system.call_elevator(10, Direction.DOWN)
    
    # Activate emergency in elevator 2
    print("2. Activating emergency in Elevator 2...")
    system.elevators[2].emergency_stop()
    
    # Verify emergency state
    assert system.elevators[2].emergency_active, "Emergency not activated"
    assert system.elevators[2].door_open, "Doors not open during emergency"
    
    # Try to use system during emergency
    print("3. Testing system during emergency...")
    elevator_id = system.call_elevator(8, Direction.UP)
    
    # Should not use emergency elevator
    assert elevator_id != 2, "System used emergency elevator"
    assert elevator_id in [1, 3], "System not using available elevators"
    
    print("\n✓ Emergency scenario test PASSED")
    return True

def test_overload_scenario():
    """Detailed overload scenario test"""
    print("\n" + "="*60)
    print("RUNNING OVERLOAD SCENARIO TEST")
    print("="*60)
    
    # This would test the actual overload sensor integration
    print("Note: Requires actual hardware sensor simulation")
    print("Test framework ready for overload detection logic")
    
    return True

def test_performance_scenario():
    """Detailed performance metrics test"""
    print("\n" + "="*60)
    print("RUNNING PERFORMANCE METRICS TEST")
    print("="*60)
    
    system = MockElevatorSystem()
    
    # Measure response times
    response_times = []
    
    for i in range(20):
        start_time = time.time()
        system.call_elevator(random.randint(1, 18), 
                           random.choice([Direction.UP, Direction.DOWN]))
        response_time = (time.time() - start_time) * 1000  # Convert to ms
        
        # Add small random delay to simulate processing
        response_time += random.uniform(10, 50)
        response_times.append(response_time)
    
    # Calculate metrics
    avg_response = sum(response_times) / len(response_times)
    max_response = max(response_times)
    min_response = min(response_times)
    
    print(f"Response Time Metrics:")
    print(f"  Average: {avg_response:.2f} ms")
    print(f"  Maximum: {max_response:.2f} ms")
    print(f"  Minimum: {min_response:.2f} ms")
    
    # Check against thresholds
    assert avg_response < 100, f"Average response {avg_response:.2f}ms > 100ms threshold"
    
    print("\n✓ Performance scenario test PASSED")
    return True

# ========== MAIN EXECUTION ==========
if __name__ == "__main__":
    print("Elevator System Test Suite")
    print("=" * 60)
    
    # Check for command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "all":
            # Run all tests
            success = run_all_tests()
            sys.exit(0 if success else 1)
        elif sys.argv[1] == "scenario":
            # Run specific scenario
            if len(sys.argv) > 2:
                test_specific_scenario(sys.argv[2])
            else:
                print("Please specify scenario name")
        elif sys.argv[1] == "unit":
            # Run only unit tests
            suite = unittest.TestLoader().loadTestsFromTestCase(TestElevatorUnit)
            unittest.TextTestRunner(verbosity=2).run(suite)
        elif sys.argv[1] == "integration":
            # Run only integration tests
            suite = unittest.TestLoader().loadTestsFromTestCase(TestElevatorSystemIntegration)
            unittest.TextTestRunner(verbosity=2).run(suite)
        elif sys.argv[1] == "performance":
            # Run performance tests
            test_performance_scenario()
    else:
        # Interactive mode
        print("\nAvailable test modes:")
        print("  python elevator_tests.py all          - Run all tests")
        print("  python elevator_tests.py unit         - Run unit tests only")
        print("  python elevator_tests.py integration  - Run integration tests only")
        print("  python elevator_tests.py scenario <name> - Run specific scenario")
        print("  python elevator_tests.py performance  - Run performance tests")
        print("\nAvailable scenarios: morning_rush, emergency, overload")
