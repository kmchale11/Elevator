"""
Elevator System Test Suite - Command Line Executable
Run with: python test_elevator.py [options]
"""

import unittest
import sys
import argparse
import time
import random
from datetime import datetime
from typing import List, Dict, Tuple

# ========== MOCK CLASSES FOR TESTING ==========
class Direction:
    UP = "UP"
    DOWN = "DOWN" 
    IDLE = "IDLE"

class ElevatorState:
    MOVING = "MOVING"
    STOPPED = "STOPPED"
    DOOR_OPEN = "DOOR_OPEN"
    MAINTENANCE = "MAINTENANCE"

class Elevator:
    """Mock elevator for testing"""
    def __init__(self, elevator_id: int, start_floor: int = 1):
        self.id = elevator_id
        self.current_floor = start_floor
        self.direction = Direction.IDLE
        self.state = ElevatorState.STOPPED
        self.target_floors = set()
        self.door_open = False
        self.is_moving = False
        self.emergency_active = False
        self.overloaded = False
        self.trip_count = 0
        self.total_weight = 0
        self.max_capacity = 800  # kg (8 people * 100kg)
        
    def move_to_floor(self, floor: int) -> int:
        """Move elevator to specified floor"""
        if self.overloaded:
            print(f"[Elevator {self.id}] Cannot move - OVERLOADED")
            return 0
            
        self.target_floors.add(floor)
        self.is_moving = True
        floors_to_move = abs(self.current_floor - floor)
        
        # Simulate movement
        if floor > self.current_floor:
            self.direction = Direction.UP
        elif floor < self.current_floor:
            self.direction = Direction.DOWN
            
        self.current_floor = floor
        self.trip_count += 1
        self.is_moving = False
        
        if floor in self.target_floors:
            self.target_floors.remove(floor)
            
        return floors_to_move
        
    def open_doors(self) -> bool:
        """Open elevator doors"""
        if self.is_moving:
            print(f"[Elevator {self.id}] Cannot open doors while moving")
            return False
        if self.emergency_active:
            print(f"[Elevator {self.id}] Emergency active - doors forced open")
            self.door_open = True
            return True
            
        self.door_open = True
        return True
        
    def close_doors(self) -> bool:
        """Close elevator doors"""
        if self.overloaded:
            print(f"[Elevator {self.id}] Cannot close doors - OVERLOADED")
            return False
            
        self.door_open = False
        return True
        
    def emergency_stop(self) -> bool:
        """Activate emergency stop"""
        self.emergency_active = True
        self.is_moving = False
        self.door_open = True  # Emergency protocol: open doors
        print(f"[Elevator {self.id}] üö® EMERGENCY STOP ACTIVATED")
        return True
        
    def update_weight(self, weight: float) -> bool:
        """Update weight sensor reading"""
        self.total_weight = weight
        self.overloaded = weight > self.max_capacity
        if self.overloaded:
            print(f"[Elevator {self.id}] ‚ö†Ô∏è  OVERLOAD DETECTED: {weight}kg > {self.max_capacity}kg")
        return self.overloaded
        
    def get_pending_stops(self) -> int:
        """Get number of pending stops"""
        return len(self.target_floors)

class ElevatorSystem:
    """Mock elevator system for testing"""
    def __init__(self):
        self.elevators = {
            1: Elevator(1, 1),    # Ground floor
            2: Elevator(2, 9),    # Mid floor  
            3: Elevator(3, 18)    # Top floor
        }
        self.floors = 18
        self.hall_calls = []
        self.call_history = []
        
    def call_elevator(self, floor: int, direction: Direction) -> int:
        """Dispatch elevator to floor call"""
        # Validate input
        if floor < 1 or floor > self.floors:
            print(f"‚ùå Invalid floor: {floor}")
            return -1
            
        if (direction == Direction.UP and floor == self.floors) or \
           (direction == Direction.DOWN and floor == 1):
            print(f"‚ùå Invalid direction for floor {floor}")
            return -1
            
        # Log the call
        call_info = {
            'floor': floor,
            'direction': direction,
            'timestamp': datetime.now(),
            'assigned': None
        }
        
        # Find best elevator using PRD algorithm
        best_elevator = None
        best_score = float('inf')
        
        for elevator in self.elevators.values():
            # Skip if in emergency or maintenance
            if elevator.emergency_active:
                continue
                
            score = self._calculate_score(elevator, floor, direction)
            
            if score < best_score:
                best_score = score
                best_elevator = elevator
                
        if best_elevator:
            call_info['assigned'] = best_elevator.id
            best_elevator.move_to_floor(floor)
            print(f"[System] Floor {floor} {direction} ‚Üí Elevator {best_elevator.id}")
            return best_elevator.id
        else:
            print(f"[System] No elevator available for floor {floor} {direction}")
            return -1
            
    def _calculate_score(self, elevator: Elevator, floor: int, direction: Direction) -> float:
        """Calculate dispatch score (lower is better)"""
        # Priority 1: Idle elevators
        if elevator.direction == Direction.IDLE and not elevator.is_moving:
            distance = abs(elevator.current_floor - floor)
            return distance * 10
            
        # Priority 2: Moving toward request in same direction
        if (elevator.direction == Direction.UP and 
            direction == Direction.UP and
            floor > elevator.current_floor):
            distance = abs(elevator.current_floor - floor)
            stops_penalty = elevator.get_pending_stops() * 20
            return distance * 10 + stops_penalty
            
        if (elevator.direction == Direction.DOWN and 
            direction == Direction.DOWN and
            floor < elevator.current_floor):
            distance = abs(elevator.current_floor - floor)
            stops_penalty = elevator.get_pending_stops() * 20
            return distance * 10 + stops_penalty
            
        # Not suitable
        return float('inf')
        
    def get_status(self) -> Dict:
        """Get system status"""
        status = {}
        for elevator_id, elevator in self.elevators.items():
            status[elevator_id] = {
                'floor': elevator.current_floor,
                'direction': elevator.direction,
                'state': elevator.state,
                'doors': 'OPEN' if elevator.door_open else 'CLOSED',
                'emergency': elevator.emergency_active,
                'overloaded': elevator.overloaded,
                'trips': elevator.trip_count,
                'pending_stops': elevator.get_pending_stops()
            }
        return status
        
    def print_status(self):
        """Print formatted system status"""
        print("\n" + "="*60)
        print("ELEVATOR SYSTEM STATUS")
        print("="*60)
        status = self.get_status()
        for elevator_id, info in status.items():
            emergency = "üö®" if info['emergency'] else ""
            overload = "‚öñÔ∏è" if info['overloaded'] else ""
            print(f"Elevator {elevator_id}: Floor {info['floor']:2d} | "
                  f"Direction: {info['direction']:4s} | "
                  f"Doors: {info['doors']:6s} | "
                  f"Trips: {info['trips']:3d} {emergency}{overload}")
        print("="*60)

# ========== TEST CLASSES ==========
class TestBasicElevator(unittest.TestCase):
    """Basic elevator unit tests"""
    
    def setUp(self):
        self.elevator = Elevator(1, start_floor=5)
        
    def test_initialization(self):
        self.assertEqual(self.elevator.id, 1)
        self.assertEqual(self.elevator.current_floor, 5)
        self.assertEqual(self.elevator.direction, Direction.IDLE)
        self.assertEqual(self.elevator.trip_count, 0)
        
    def test_move_up(self):
        floors = self.elevator.move_to_floor(10)
        self.assertEqual(self.elevator.current_floor, 10)
        self.assertEqual(floors, 5)
        self.assertEqual(self.elevator.trip_count, 1)
        
    def test_move_down(self):
        self.elevator.current_floor = 15
        floors = self.elevator.move_to_floor(3)
        self.assertEqual(self.elevator.current_floor, 3)
        self.assertEqual(floors, 12)
        
    def test_door_operations(self):
        self.assertTrue(self.elevator.open_doors())
        self.assertTrue(self.elevator.door_open)
        self.assertTrue(self.elevator.close_doors())
        self.assertFalse(self.elevator.door_open)
        
    def test_emergency_stop(self):
        self.elevator.is_moving = True
        self.elevator.door_open = False
        self.elevator.emergency_stop()
        self.assertTrue(self.elevator.emergency_active)
        self.assertFalse(self.elevator.is_moving)
        self.assertTrue(self.elevator.door_open)
        
    def test_overload_detection(self):
        self.elevator.update_weight(500)
        self.assertFalse(self.elevator.overloaded)
        self.elevator.update_weight(900)
        self.assertTrue(self.elevator.overloaded)
        
    def test_cannot_move_when_overloaded(self):
        self.elevator.update_weight(900)  # Trigger overload
        floors = self.elevator.move_to_floor(10)
        self.assertEqual(floors, 0)  # Should not move

class TestSystemIntegration(unittest.TestCase):
    """System integration tests"""
    
    def setUp(self):
        self.system = ElevatorSystem()
        
    def test_system_initialization(self):
        self.assertEqual(len(self.system.elevators), 3)
        self.assertEqual(self.system.elevators[1].current_floor, 1)
        self.assertEqual(self.system.elevators[2].current_floor, 9)
        self.assertEqual(self.system.elevators[3].current_floor, 18)
        
    def test_basic_hall_call(self):
        elevator_id = self.system.call_elevator(5, Direction.UP)
        self.assertIn(elevator_id, [1, 2, 3])
        self.assertEqual(self.system.elevators[elevator_id].current_floor, 5)
        
    def test_nearest_idle_elevator(self):
        # Call from floor 6 - should go to elevator 2 (at floor 9, distance 3)
        # Actually elevator 1 is at floor 1 (distance 5), elevator 2 at 9 (distance 3)
        elevator_id = self.system.call_elevator(6, Direction.UP)
        self.assertEqual(elevator_id, 2)  # Nearest idle
        
    def test_invalid_floor_call(self):
        elevator_id = self.system.call_elevator(0, Direction.UP)
        self.assertEqual(elevator_id, -1)
        elevator_id = self.system.call_elevator(19, Direction.DOWN)
        self.assertEqual(elevator_id, -1)
        
    def test_invalid_direction(self):
        # Floor 1 cannot go DOWN
        elevator_id = self.system.call_elevator(1, Direction.DOWN)
        self.assertEqual(elevator_id, -1)
        # Floor 18 cannot go UP
        elevator_id = self.system.call_elevator(18, Direction.UP)
        self.assertEqual(elevator_id, -1)

class TestDispatchingAlgorithm(unittest.TestCase):
    """Tests for dispatching algorithm"""
    
    def setUp(self):
        self.system = ElevatorSystem()
        
    def test_idle_elevator_priority(self):
        # Make elevator 2 busy
        self.system.elevators[2].is_moving = True
        self.system.elevators[2].direction = Direction.UP
        
        # Call should go to nearest idle (elevator 1 or 3)
        elevator_id = self.system.call_elevator(10, Direction.UP)
        self.assertIn(elevator_id, [1, 3])
        self.assertNotEqual(elevator_id, 2)
        
    def test_moving_toward_request(self):
        # Set elevator 1 moving UP from floor 3
        self.system.elevators[1].current_floor = 3
        self.system.elevators[1].direction = Direction.UP
        self.system.elevators[1].is_moving = True
        self.system.elevators[1].target_floors = {10}
        
        # Set elevator 2 idle at floor 9
        self.system.elevators[2].is_moving = False
        
        # Call from floor 5 going UP
        # Elevator 1 is moving toward it, should get preference
        elevator_id = self.system.call_elevator(5, Direction.UP)
        self.assertEqual(elevator_id, 1)
        
    def test_emergency_elevator_skip(self):
        # Put elevator 2 in emergency
        self.system.elevators[2].emergency_stop()
        
        # Call should not use elevator 2
        elevator_id = self.system.call_elevator(5, Direction.UP)
        self.assertNotEqual(elevator_id, 2)
        self.assertIn(elevator_id, [1, 3])

class TestScenarioBased(unittest.TestCase):
    """Real-world scenario tests"""
    
    def test_morning_rush_hour(self):
        """Test morning upward traffic"""
        system = ElevatorSystem()
        
        # Morning rush: many people going up from lower floors
        destinations = [8, 12, 15, 10, 18, 7, 14, 9, 11, 16]
        assigned_elevators = []
        
        for dest in destinations:
            elevator_id = system.call_elevator(1, Direction.UP)
            if elevator_id > 0:
                system.elevators[elevator_id].move_to_floor(dest)
                assigned_elevators.append(elevator_id)
                
        # Should use all elevators
        unique_elevators = set(assigned_elevators)
        self.assertEqual(len(unique_elevators), 3)
        
        # Check trip distribution
        trips = {1: 0, 2: 0, 3: 0}
        for eid in assigned_elevators:
            trips[eid] += 1
            
        # All should have trips
        self.assertTrue(all(trips[eid] > 0 for eid in trips))
        print(f"\nMorning Rush Results:")
        print(f"  Total trips: {len(assigned_elevators)}")
        print(f"  Elevator 1 trips: {trips[1]}")
        print(f"  Elevator 2 trips: {trips[2]}")
        print(f"  Elevator 3 trips: {trips[3]}")
        
    def test_lunch_hour(self):
        """Test bidirectional lunch traffic"""
        system = ElevatorSystem()
        
        # Lunch hour: people going both directions
        # Some going down to cafeteria (floor 2)
        down_calls = [(10, Direction.DOWN), (15, Direction.DOWN), (8, Direction.DOWN)]
        # Some going up after lunch
        up_calls = [(2, Direction.UP), (2, Direction.UP), (2, Direction.UP)]
        
        all_calls = down_calls + up_calls
        results = []
        
        for floor, direction in all_calls:
            elevator_id = system.call_elevator(floor, direction)
            if elevator_id > 0:
                results.append(elevator_id)
                
        self.assertEqual(len(results), 6)
        
    def test_emergency_scenario(self):
        """Test emergency handling"""
        system = ElevatorSystem()
        
        # Normal operation
        system.call_elevator(5, Direction.UP)
        
        # Activate emergency in elevator 2
        system.elevators[2].emergency_stop()
        
        # Verify emergency state
        self.assertTrue(system.elevators[2].emergency_active)
        
        # System should still work with other elevators
        elevator_id = system.call_elevator(10, Direction.DOWN)
        self.assertNotEqual(elevator_id, 2)
        
    def test_overload_scenario(self):
        """Test overload detection"""
        system = ElevatorSystem()
        
        # Overload elevator 1
        system.elevators[1].update_weight(850)
        self.assertTrue(system.elevators[1].overloaded)
        
        # Try to move overloaded elevator
        floors = system.elevators[1].move_to_floor(10)
        self.assertEqual(floors, 0)  # Should not move
        
        # Doors should not close when overloaded
        system.elevators[1].open_doors()
        can_close = system.elevators[1].close_doors()
        self.assertFalse(can_close)

class TestPerformanceMetrics(unittest.TestCase):
    """Performance metric tests"""
    
    def test_response_time(self):
        """Test average response time < 30 seconds (simulated)"""
        system = ElevatorSystem()
        response_times = []
        
        # Simulate 10 calls with varying response times
        for i in range(1, 11):
            # Simulate processing time (0.1-0.5 seconds)
            response_time = 0.1 * i + random.uniform(0, 0.1)
            response_times.append(response_time)
            
            # Make actual call
            system.call_elevator(i, Direction.UP)
            
        avg_response = sum(response_times) / len(response_times)
        
        # Convert to seconds for assertion
        self.assertLess(avg_response, 2.0,  # Using 2s as reasonable simulated limit
                       f"Average response {avg_response:.2f}s too high")
        
    def test_throughput(self):
        """Test system can handle multiple rapid calls"""
        system = ElevatorSystem()
        successful_calls = 0
        
        # Make 20 rapid calls
        for i in range(20):
            floor = random.randint(1, 18)
            direction = random.choice([Direction.UP, Direction.DOWN])
            elevator_id = system.call_elevator(floor, direction)
            if elevator_id > 0:
                successful_calls += 1
                
        # Should handle most calls
        self.assertGreater(successful_calls, 15,
                          f"Only {successful_calls}/20 calls handled")

# ========== COMMAND LINE TEST RUNNER ==========
def run_all_tests(verbosity=2):
    """Run all test suites"""
    print("üöÄ Running Elevator System Test Suite")
    print("="*60)
    
    # Create test loader
    loader = unittest.TestLoader()
    
    # Load all test cases
    test_classes = [
        TestBasicElevator,
        TestSystemIntegration,
        TestDispatchingAlgorithm,
        TestScenarioBased,
        TestPerformanceMetrics
    ]
    
    # Create test suite
    suite = unittest.TestSuite()
    for test_class in test_classes:
        tests = loader.loadTestsFromTestCase(test_class)
        suite.addTests(tests)
        
    # Run tests
    runner = unittest.TextTestRunner(verbosity=verbosity)
    result = runner.run(suite)
    
    # Print summary
    print("\n" + "="*60)
    print("TEST SUMMARY")
    print("="*60)
    print(f"Tests Run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    
    if result.failures:
        print("\nFAILURES:")
        for test, traceback in result.failures:
            test_name = str(test).split()[0]
            print(f"  ‚ùå {test_name}")
            
    if result.errors:
        print("\nERRORS:")
        for test, traceback in result.errors:
            test_name = str(test).split()[0]
            print(f"  ‚ö†Ô∏è  {test_name}")
            
    if result.wasSuccessful():
        print("\n‚úÖ All tests passed!")
    else:
        print("\n‚ùå Some tests failed")
        
    return result.wasSuccessful()

def run_scenario_tests():
    """Run interactive scenario tests"""
    print("\nüéØ SCENARIO TESTS")
    print("="*60)
    
    scenarios = [
        ("Morning Rush Hour", test_morning_rush),
        ("Lunch Hour Traffic", test_lunch_hour),
        ("Emergency Situation", test_emergency),
        ("Overload Condition", test_overload),
        ("Peak Performance", test_performance)
    ]
    
    results = []
    for name, test_func in scenarios:
        print(f"\nRunning: {name}")
        print("-"*40)
        try:
            success = test_func()
            results.append((name, success))
            if success:
                print(f"‚úÖ {name} - PASSED")
            else:
                print(f"‚ùå {name} - FAILED")
        except Exception as e:
            print(f"‚ö†Ô∏è  {name} - ERROR: {e}")
            results.append((name, False))
            
    # Summary
    print("\n" + "="*60)
    print("SCENARIO SUMMARY")
    print("="*60)
    passed = sum(1 for _, success in results if success)
    total = len(results)
    print(f"Passed: {passed}/{total}")
    
    return passed == total

def test_morning_rush():
    """Test morning rush scenario"""
    system = ElevatorSystem()
    
    print("Simulating 8:00 AM rush hour...")
    print("10 people entering from ground floor going to various floors")
    
    destinations = [8, 12, 15, 10, 18, 7, 14, 9, 11, 16]
    trips = {1: 0, 2: 0, 3: 0}
    
    for i, dest in enumerate(destinations, 1):
        print(f"  Person {i}: Ground floor ‚Üí Floor {dest}")
        elevator_id = system.call_elevator(1, Direction.UP)
        if elevator_id > 0:
            system.elevators[elevator_id].move_to_floor(dest)
            trips[elevator_id] += 1
            
    system.print_status()
    
    # Verify all elevators were used
    return all(trips[eid] > 0 for eid in trips)

def test_lunch_hour():
    """Test lunch hour scenario"""
    system = ElevatorSystem()
    
    print("Simulating 12:00 PM lunch hour...")
    print("Mixed traffic: some going down to cafeteria, some coming back up")
    
    # Down to cafeteria (floor 2)
    for floor in [10, 15, 8]:
        print(f"  Floor {floor} ‚Üí Cafeteria (Floor 2)")
        system.call_elevator(floor, Direction.DOWN)
        
    # Back up to offices
    for dest in [10, 12, 15]:
        print(f"  Cafeteria (Floor 2) ‚Üí Floor {dest}")
        system.call_elevator(2, Direction.UP)
        
    system.print_status()
    return True

def test_emergency():
    """Test emergency scenario"""
    system = ElevatorSystem()
    
    print("Simulating emergency situation...")
    
    # Normal operation first
    print("1. Normal call: Floor 5 ‚Üí UP")
    system.call_elevator(5, Direction.UP)
    
    # Emergency!
    print("\n2. üö® EMERGENCY STOP ACTIVATED on Elevator 2!")
    system.elevators[2].emergency_stop()
    
    # Verify emergency state
    print("\n3. Verifying emergency state...")
    if not system.elevators[2].emergency_active:
        print("  ‚ùå Emergency not activated!")
        return False
        
    if not system.elevators[2].door_open:
        print("  ‚ùå Doors not open during emergency!")
        return False
        
    print("  ‚úÖ Emergency properly activated")
    
    # Try to use system
    print("\n4. Testing system during emergency...")
    elevator_id = system.call_elevator(8, Direction.UP)
    
    if elevator_id == 2:
        print("  ‚ùå System used emergency elevator!")
        return False
        
    print(f"  ‚úÖ System correctly used Elevator {elevator_id}")
    
    system.print_status()
    return True

def test_overload():
    """Test overload scenario"""
    system = ElevatorSystem()
    
    print("Testing overload detection...")
    
    # Normal weight
    print("1. Normal load (500kg)")
    overloaded = system.elevators[1].update_weight(500)
    if overloaded:
        print("  ‚ùå False overload detection!")
        return False
    print("  ‚úÖ Normal load accepted")
    
    # Overload
    print("\n2. Overload condition (900kg)")
    overloaded = system.elevators[1].update_weight(900)
    if not overloaded:
        print("  ‚ùå Overload not detected!")
        return False
    print("  ‚úÖ Overload correctly detected")
    
    # Try to move overloaded elevator
    print("\n3. Attempting to move overloaded elevator...")
    floors = system.elevators[1].move_to_floor(10)
    if floors > 0:
        print("  ‚ùå Overloaded elevator moved!")
        return False
    print("  ‚úÖ Overloaded elevator prevented from moving")
    
    # Door operations
    print("\n4. Testing door operations...")
    system.elevators[1].open_doors()
    can_close = system.elevators[1].close_doors()
    if can_close:
        print("  ‚ùå Doors closed despite overload!")
        return False
    print("  ‚úÖ Doors prevented from closing when overloaded")
    
    system.print_status()
    return True

def test_performance():
    """Test performance metrics"""
    import time
    
    system = ElevatorSystem()
    
    print("Testing system performance...")
    
    # Measure response times
    print("\n1. Measuring response times for 10 calls:")
    response_times = []
    
    for i in range(1, 11):
        start = time.time()
        system.call_elevator(i, Direction.UP)
        response_time = (time.time() - start) * 1000  # Convert to ms
        response_times.append(response_time)
        print(f"  Call {i}: {response_time:.1f} ms")
        
    avg_response = sum(response_times) / len(response_times)
    print(f"\n  Average response: {avg_response:.1f} ms")
    
    # Throughput test
    print("\n2. Testing throughput (20 rapid calls):")
    successful = 0
    start = time.time()
    
    for i in range(20):
        floor = random.randint(1, 18)
        direction = random.choice([Direction.UP, Direction.DOWN])
        elevator_id = system.call_elevator(floor, direction)
        if elevator_id > 0:
            successful += 1
            
    total_time = time.time() - start
    calls_per_second = successful / total_time if total_time > 0 else 0
    
    print(f"  Handled: {successful}/20 calls")
    print(f"  Time: {total_time:.2f} seconds")
    print(f"  Throughput: {calls_per_second:.1f} calls/second")
    
    system.print_status()
    
    # Check metrics
    if avg_response > 100:  # 100ms threshold for simulated tests
        print("  ‚ö†Ô∏è  Response time higher than expected")
        return False
        
    if successful < 15:
        print("  ‚ö†Ô∏è  Throughput lower than expected")
        return False
        
    return True

def run_simulation():
    """Run an interactive simulation"""
    print("\nüéÆ INTERACTIVE SIMULATION")
    print("="*60)
    print("Commands:")
    print("  call <floor> <up/down>  - Call elevator to floor")
    print("  goto <elevator> <floor> - Send elevator to floor")
    print("  emergency <elevator>    - Activate emergency stop")
    print("  weight <elevator> <kg>  - Set elevator weight")
    print("  status                  - Show system status")
    print("  help                    - Show commands")
    print("  exit                    - End simulation")
    print("="*60)
    
    system = ElevatorSystem()
    
    while True:
        try:
            command = input("\n> ").strip().lower()
            
            if command == "exit":
                print("Ending simulation...")
                break
                
            elif command == "status":
                system.print_status()
                
            elif command == "help":
                print("Commands: call, goto, emergency, weight, status, help, exit")
                
            elif command.startswith("call "):
                parts = command.split()
                if len(parts) == 3:
                    try:
                        floor = int(parts[1])
                        direction = Direction.UP if parts[2] == "up" else Direction.DOWN
                        elevator_id = system.call_elevator(floor, direction)
                        if elevator_id > 0:
                            print(f"‚úÖ Elevator {elevator_id} dispatched")
                        else:
                            print("‚ùå No elevator available")
                    except:
                        print("‚ùå Usage: call <floor> <up/down>")
                else:
                    print("‚ùå Usage: call <floor> <up/down>")
                    
            elif command.startswith("goto "):
                parts = command.split()
                if len(parts) == 3:
                    try:
                        elevator_id = int(parts[1])
                        floor = int(parts[2])
                        if elevator_id in system.elevators:
                            floors = system.elevators[elevator_id].move_to_floor(floor)
                            print(f"‚úÖ Elevator {elevator_id} moving to floor {floor}")
                        else:
                            print(f"‚ùå Invalid elevator ID: {elevator_id}")
                    except:
                        print("‚ùå Usage: goto <elevator> <floor>")
                else:
                    print("‚ùå Usage: goto <elevator> <floor>")
                    
            elif command.startswith("emergency "):
                parts = command.split()
                if len(parts) == 2:
                    try:
                        elevator_id = int(parts[1])
                        if elevator_id in system.elevators:
                            system.elevators[elevator_id].emergency_stop()
                            print(f"‚úÖ Emergency stop activated on Elevator {elevator_id}")
                        else:
                            print(f"‚ùå Invalid elevator ID: {elevator_id}")
                    except:
                        print("‚ùå Usage: emergency <elevator>")
                else:
                    print("‚ùå Usage: emergency <elevator>")
                    
            elif command.startswith("weight "):
                parts = command.split()
                if len(parts) == 3:
                    try:
                        elevator_id = int(parts[1])
                        weight = float(parts[2])
                        if elevator_id in system.elevators:
                            overloaded = system.elevators[elevator_id].update_weight(weight)
                            if overloaded:
                                print(f"‚ö†Ô∏è  Elevator {elevator_id} OVERLOADED: {weight}kg")
                            else:
                                print(f"‚úÖ Elevator {elevator_id} weight: {weight}kg")
                        else:
                            print(f"‚ùå Invalid elevator ID: {elevator_id}")
                    except:
                        print("‚ùå Usage: weight <elevator> <kg>")
                else:
                    print("‚ùå Usage: weight <elevator> <kg>")
                    
            else:
                print("‚ùå Unknown command. Type 'help' for commands.")
                
        except KeyboardInterrupt:
            print("\n\nSimulation interrupted")
            break
        except Exception as e:
            print(f"‚ùå Error: {e}")

# ========== COMMAND LINE INTERFACE ==========
def main():
    """Main command line interface"""
    parser = argparse.ArgumentParser(
        description='Elevator System Test Suite',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python test_elevator.py all          # Run all unit tests
  python test_elevator.py scenario     # Run scenario tests
  python test_elevator.py sim          # Run interactive simulation
  python test_elevator.py -v           # Run with verbose output
  python test_elevator.py --list       # List all test scenarios
        """
    )
    
    parser.add_argument(
        'command',
        nargs='?',
        default='all',
        choices=['all', 'scenario', 'sim', 'list'],
        help='Test command to run'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output'
    )
    
    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='Quiet output'
    )
    
    parser.add_argument(
        '--list',
        action='store_true',
        help='List all available tests'
    )
    
    args = parser.parse_args()
    
    # Set verbosity
    if args.quiet:
        verbosity = 0
    elif args.verbose:
        verbosity = 2
    else:
        verbosity = 1
        
    # List tests
    if args.list or args.command == 'list':
        print("Available Test Categories:")
        print("  1. Unit Tests - Basic elevator functionality")
        print("  2. Integration Tests - System-wide functionality")
        print("  3. Algorithm Tests - Dispatching logic")
        print("  4. Scenario Tests - Real-world scenarios")
        print("  5. Performance Tests - System metrics")
        print("\nAvailable Commands:")
        print("  all      - Run all unit tests")
        print("  scenario - Run scenario tests")
        print("  sim      - Interactive simulation")
        print("  list     - List available tests")
        return
    
    # Execute command
    if args.command == 'all':
        success = run_all_tests(verbosity)
        sys.exit(0 if success else 1)
        
    elif args.command == 'scenario':
        success = run_scenario_tests()
        sys.exit(0 if success else 1)
        
    elif args.command == 'sim':
        run_simulation()
        
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
